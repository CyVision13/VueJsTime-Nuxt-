/*!
 * vue-validate v1.0.1
 * (c) 2016 mark fluehmann
 * Released under the MIT License.
 * 
 * Install: 
 * Vue.use(require('vue-resource')) - vue-validate requires a vue-resource instance first
 * var VueValidate = require('vue-validate')
 * Vue.use(require(VueValidate))
 * window.validate = new VueValidate
 *
 * Usage:
 * validate.request('a-server-side-validation-url', validationObject).then( function(response) {
 *     handle response 
 * }, function(xhrObj) {
 *     handle errors
 * });
 *
 * Return Message:
 * validation messages are processed as object as
 * - if successfully validated: { isValidated: true }
 * - if validation failed:      { isValidated: fals, attributeA: 'validation message' }
 * 
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.VueValidate = factory();
}(this, function () { 'use strict';

    /* export default for holding the Vue reference */
    var instance = {};

    /**
    * Notify constructor
    * @param {Object} [options]
    */
    var Validation = (function () {
        function Validation() {

            /* global references */
            // none so far

            /* option defaults */
            var defaults = {
            };

            /* extend defaults with given options */
            this.options = {};
            if (arguments[0] && typeof arguments[0] === "object") {
                this.options = extendDefaults(defaults, arguments[0]);
            }
        }

        /**
         * Extend defaults with given custom options
         * @param  object source       Object defaults
         * @param  object properties   custom options
         * @return object              combined new defaults
         */
        function extendDefaults(source, properties) {
            for (var property in properties) {
                if (properties.hasOwnProperty(property)) {
                    source[property] = properties[property];
                }
            }
            return source;
        }

        Validation.prototype.request = function validate(url, object) {

            // resolve http resource
            var http = instance.Vue.http;

            // create new promise for async validation
            return new Promise(function(resolve, reject) {

                // reject with http code error
                if( !http && typeof url != 'string' && typeof object != 'object' ) {
                    reject(Error('http options not sufficient for an ajax request'));
                }

                // parse response to resolve
                else {       
                    // handle ajax validation request
                    http.post(url, object).then( function(response) {
                        resolve( parseResponse( response ) );
                    });
                }
            });
        };

        return Validation;

    })();

    function parseResponse( response ) {
        // create new promise to async response parsing
        return new Promise(function(resolve, reject) {
 
            // prepare for further processing
            var ajaxStatus = response.status;
            var ajaxResponse = response.data;
            var result = {};

            // reject with http code error
            if( response.status != '200' ) {
                reject(Error('could not resolve http resource. validation aborted'));
            }

            // parse response to resolve
            else {
                // if ajax response length is null, object is validated
                if( Object.keys(ajaxResponse).length == 0 ) {
                    result = { isValidated: true };
                }
                // prepare response with validation messages
                else {
                    result['isValidated'] = false;
                    for ( var key in ajaxResponse ) {             
                        if ( ajaxResponse.hasOwnProperty(key) ) {
                            result[key] = ajaxResponse[key][0];
                        }
                    };                    
                }
                resolve(result);
            };
        });
    }

    function applyOverride (Vue) {
        /* override Vue's init */
        var init = Vue.prototype._init;
        Vue.prototype._init = function (options) {
             init.call(this, options);
        };

        /* override Vue's destroy process */
        var destroy = Vue.prototype._destroy;
        Vue.prototype._destroy = function () {
            destroy.apply(this, arguments);
        };
    };

    /* Installation */
    Validation.installed = false;
    Validation.install = function (externalVue) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (Validation.installed) {
          warn('plugin already installed.');
          return;
        }

        var http = externalVue.http;
        if ( !http) {
          warn('please first initialise vue-resource (Vue.use("vue-resource").');
          return;
        }

        //applyOverride(Vue);
        instance.Vue = externalVue;
        Validation.installed = true;
    };

    /* set plugin version */
    Validation.version = '1.0.0';

    /* auto install */
    if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(Validation);
    }

    return Validation;

}));